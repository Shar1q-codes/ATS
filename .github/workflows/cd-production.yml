name: Deploy to Production

on:
  push:
    branches: [main]
    tags: ["v*"]
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - production-blue
          - production-green
      skip_tests:
        description: "Skip pre-deployment tests"
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Pre-deployment Checks
  pre-deployment-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    if: ${{ !inputs.skip_tests }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check if staging tests passed
        uses: actions/github-script@v6
        with:
          script: |
            const { data: workflows } = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'cd-staging.yml',
              branch: 'develop',
              status: 'completed',
              per_page: 1
            });

            if (workflows.workflow_runs.length === 0 || workflows.workflow_runs[0].conclusion !== 'success') {
              core.setFailed('Latest staging deployment did not pass. Please ensure staging is working before production deployment.');
            }

      - name: Verify release notes
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          # Check if release notes exist for this tag
          if ! gh release view ${{ github.ref_name }} --json body | jq -r '.body' | grep -q .; then
            echo "Release notes are required for production deployment"
            exit 1
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Build and Push Production Images
  build-and-push:
    name: Build and Push Production Images
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    if: always() && (needs.pre-deployment-checks.result == 'success' || inputs.skip_tests)
    permissions:
      contents: read
      packages: write

    outputs:
      backend-image: ${{ steps.meta-backend.outputs.tags }}
      frontend-image: ${{ steps.meta-frontend.outputs.tags }}
      backend-digest: ${{ steps.build-backend.outputs.digest }}
      frontend-digest: ${{ steps.build-frontend.outputs.digest }}
      version: ${{ steps.version.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate version
        id: version
        run: |
          if [[ $GITHUB_REF == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            VERSION=${GITHUB_SHA::8}
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for backend
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend
          tags: |
            type=ref,event=branch
            type=ref,event=tag
            type=sha,prefix={{branch}}-
            type=raw,value=production
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ steps.version.outputs.version }}

      - name: Extract metadata for frontend
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend
          tags: |
            type=ref,event=branch
            type=ref,event=tag
            type=sha,prefix={{branch}}-
            type=raw,value=production
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ steps.version.outputs.version }}

      - name: Build and push backend image
        id: build-backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile.prod
          push: true
          tags: ${{ steps.meta-backend.outputs.tags }}
          labels: ${{ steps.meta-backend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64
          build-args: |
            VERSION=${{ steps.version.outputs.version }}
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}

      - name: Build and push frontend image
        id: build-frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile.prod
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64
          build-args: |
            NEXT_PUBLIC_API_URL=${{ secrets.PRODUCTION_API_URL }}
            NEXT_PUBLIC_SUPABASE_URL=${{ secrets.PRODUCTION_SUPABASE_URL }}
            NEXT_PUBLIC_SUPABASE_ANON_KEY=${{ secrets.PRODUCTION_SUPABASE_ANON_KEY }}
            NEXT_PUBLIC_NODE_ENV=production
            VERSION=${{ steps.version.outputs.version }}

      - name: Sign images with cosign
        uses: sigstore/cosign-installer@v3
        with:
          cosign-release: "v2.2.0"

      - name: Sign backend image
        run: |
          cosign sign --yes ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend@${{ steps.build-backend.outputs.digest }}

      - name: Sign frontend image
        run: |
          cosign sign --yes ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend@${{ steps.build-frontend.outputs.digest }}

  # Database Migration with Rollback Support
  migrate-database:
    name: Run Database Migrations
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: Install dependencies
        working-directory: ./backend
        run: npm ci

      - name: Create database backup
        run: |
          # Create pre-migration backup
          echo "Creating pre-migration backup..."
          # This would typically connect to production database and create backup
          # Implementation depends on your backup strategy

      - name: Run database migrations
        working-directory: ./backend
        run: |
          # Dry run first
          npm run migration:show

          # Run actual migrations
          npm run migration:run
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}
          NODE_ENV: production

      - name: Verify migration
        working-directory: ./backend
        run: npm run schema:verify
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}
          NODE_ENV: production

  # Blue-Green Deployment
  deploy-blue-green:
    name: Blue-Green Deployment
    runs-on: ubuntu-latest
    needs: [build-and-push, migrate-database]
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.PRODUCTION_SSH_PRIVATE_KEY }}

      - name: Add production servers to known hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_KNOWN_HOSTS }}" >> ~/.ssh/known_hosts

      - name: Determine deployment target
        id: deployment-target
        run: |
          # Determine which environment is currently active
          CURRENT_ENV=$(ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "cat /opt/ai-ats/current-env.txt || echo 'blue'")

          if [ "$CURRENT_ENV" = "blue" ]; then
            TARGET_ENV="green"
          else
            TARGET_ENV="blue"
          fi

          echo "current-env=$CURRENT_ENV" >> $GITHUB_OUTPUT
          echo "target-env=$TARGET_ENV" >> $GITHUB_OUTPUT
          echo "Deploying to $TARGET_ENV environment (current: $CURRENT_ENV)"

      - name: Deploy to target environment
        run: |
          TARGET_ENV="${{ steps.deployment-target.outputs.target-env }}"

          # Copy deployment files
          scp -r production/ ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }}:/tmp/ai-ats-deploy-$TARGET_ENV/
          scp docker-compose.prod.yml ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }}:/tmp/ai-ats-deploy-$TARGET_ENV/

          # Deploy to target environment
          ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << EOF
            set -e
            
            cd /tmp/ai-ats-deploy-$TARGET_ENV
            
            # Create environment-specific configuration
            cat > .env.production << 'ENVEOF'
            NODE_ENV=production
            
            # Database Configuration
            DATABASE_URL=${{ secrets.PRODUCTION_DATABASE_URL }}
            DATABASE_READ_URL=${{ secrets.PRODUCTION_DATABASE_READ_URL }}
            REDIS_URL=${{ secrets.PRODUCTION_REDIS_URL }}
            
            # JWT Configuration
            JWT_SECRET=${{ secrets.PRODUCTION_JWT_SECRET }}
            JWT_EXPIRES_IN=7d
            
            # OpenAI Configuration
            OPENAI_API_KEY=${{ secrets.PRODUCTION_OPENAI_API_KEY }}
            
            # Email Configuration
            POSTMARK_API_KEY=${{ secrets.PRODUCTION_POSTMARK_API_KEY }}
            
            # Application Configuration
            PORT=300$( [ "$TARGET_ENV" = "blue" ] && echo "1" || echo "2" )
            CORS_ORIGIN=${{ secrets.PRODUCTION_FRONTEND_URL }}
            
            # Frontend Configuration
            NEXT_PUBLIC_API_URL=${{ secrets.PRODUCTION_API_URL }}
            NEXT_PUBLIC_SUPABASE_URL=${{ secrets.PRODUCTION_SUPABASE_URL }}
            NEXT_PUBLIC_SUPABASE_ANON_KEY=${{ secrets.PRODUCTION_SUPABASE_ANON_KEY }}
            NEXT_PUBLIC_NODE_ENV=production
            
            # Monitoring
            SENTRY_DSN=${{ secrets.PRODUCTION_SENTRY_DSN }}
            LOG_LEVEL=warn
            
            # Version
            VERSION=${{ needs.build-and-push.outputs.version }}
            ENVEOF
            
            # Update docker-compose with new images and ports
            sed -i "s|image: .*backend.*|image: ${{ needs.build-and-push.outputs.backend-image }}|g" docker-compose.prod.yml
            sed -i "s|image: .*frontend.*|image: ${{ needs.build-and-push.outputs.frontend-image }}|g" docker-compose.prod.yml
            
            # Adjust ports for blue-green deployment
            if [ "$TARGET_ENV" = "green" ]; then
              sed -i 's/3001:3001/3002:3001/g' docker-compose.prod.yml
              sed -i 's/3000:3000/3001:3000/g' docker-compose.prod.yml
            fi
            
            # Pull and deploy
            docker-compose -f docker-compose.prod.yml --env-file .env.production pull
            docker-compose -f docker-compose.prod.yml --env-file .env.production up -d
            
            # Wait for services to be healthy
            timeout 600 bash -c 'until docker-compose -f docker-compose.prod.yml ps | grep -q "Up (healthy)"; do sleep 10; done'
            
            echo "Deployment to $TARGET_ENV completed successfully"
          EOF

      - name: Health check target environment
        run: |
          TARGET_ENV="${{ steps.deployment-target.outputs.target-env }}"

          # Determine target ports
          if [ "$TARGET_ENV" = "green" ]; then
            BACKEND_PORT=3002
            FRONTEND_PORT=3001
          else
            BACKEND_PORT=3001
            FRONTEND_PORT=3000
          fi

          # Wait for services to be ready
          sleep 60

          # Health checks
          curl -f http://${{ secrets.PRODUCTION_HOST }}:$BACKEND_PORT/api/health
          curl -f http://${{ secrets.PRODUCTION_HOST }}:$FRONTEND_PORT/api/health

          echo "Health checks passed for $TARGET_ENV environment"

      - name: Run smoke tests on target environment
        run: |
          TARGET_ENV="${{ steps.deployment-target.outputs.target-env }}"

          # Determine target ports
          if [ "$TARGET_ENV" = "green" ]; then
            FRONTEND_PORT=3001
          else
            FRONTEND_PORT=3000
          fi

          # Basic smoke tests
          curl -f http://${{ secrets.PRODUCTION_HOST }}:$FRONTEND_PORT/

          # Additional smoke tests would go here
          echo "Smoke tests passed for $TARGET_ENV environment"

      - name: Switch traffic to target environment
        run: |
          TARGET_ENV="${{ steps.deployment-target.outputs.target-env }}"
          CURRENT_ENV="${{ steps.deployment-target.outputs.current-env }}"

          ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << EOF
            set -e
            
            # Update load balancer configuration to point to new environment
            # This would typically update nginx configuration or load balancer rules
            
            # Update current environment marker
            echo "$TARGET_ENV" > /opt/ai-ats/current-env.txt
            
            # Reload nginx or load balancer
            sudo nginx -s reload
            
            echo "Traffic switched from $CURRENT_ENV to $TARGET_ENV"
          EOF

      - name: Verify production deployment
        run: |
          # Wait for traffic switch to take effect
          sleep 30

          # Verify production endpoints
          curl -f ${{ secrets.PRODUCTION_API_URL }}/api/health
          curl -f ${{ secrets.PRODUCTION_FRONTEND_URL }}/api/health

          echo "Production deployment verification successful"

      - name: Cleanup old environment
        run: |
          CURRENT_ENV="${{ steps.deployment-target.outputs.current-env }}"

          ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << EOF
            set -e
            
            # Stop old environment
            cd /tmp/ai-ats-deploy-$CURRENT_ENV
            docker-compose -f docker-compose.prod.yml down
            
            # Clean up old images
            docker image prune -f
            
            echo "Old environment ($CURRENT_ENV) cleaned up"
          EOF

  # Post-deployment Tests
  post-deployment-tests:
    name: Post-deployment Tests
    runs-on: ubuntu-latest
    needs: deploy-blue-green

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Install Playwright
        working-directory: ./frontend
        run: npx playwright install --with-deps

      - name: Run production smoke tests
        working-directory: ./frontend
        run: npx playwright test --grep="@production"
        env:
          PLAYWRIGHT_BASE_URL: ${{ secrets.PRODUCTION_FRONTEND_URL }}
          API_BASE_URL: ${{ secrets.PRODUCTION_API_URL }}

      - name: Run API tests
        run: |
          # Comprehensive API testing
          curl -f ${{ secrets.PRODUCTION_API_URL }}/api/health

          # Test key endpoints
          # Add more specific API tests here

  # Rollback on Failure
  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [deploy-blue-green, post-deployment-tests]
    if: failure()
    environment: production

    steps:
      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.PRODUCTION_SSH_PRIVATE_KEY }}

      - name: Rollback deployment
        run: |
          ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'EOF'
            set -e
            
            # Read current environment
            CURRENT_ENV=$(cat /opt/ai-ats/current-env.txt)
            
            # Determine previous environment
            if [ "$CURRENT_ENV" = "blue" ]; then
              PREVIOUS_ENV="green"
            else
              PREVIOUS_ENV="blue"
            fi
            
            # Switch back to previous environment
            echo "$PREVIOUS_ENV" > /opt/ai-ats/current-env.txt
            
            # Update load balancer to point back to previous environment
            sudo nginx -s reload
            
            # Start previous environment if it's not running
            cd /tmp/ai-ats-deploy-$PREVIOUS_ENV
            docker-compose -f docker-compose.prod.yml up -d
            
            echo "Rollback to $PREVIOUS_ENV completed"
          EOF

  # Create Release
  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [deploy-blue-green, post-deployment-tests]
    if: startsWith(github.ref, 'refs/tags/') && success()

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ github.ref }}
          body: |
            ## Changes in this Release

            ### Backend
            - Image: ${{ needs.build-and-push.outputs.backend-image }}
            - Digest: ${{ needs.build-and-push.outputs.backend-digest }}

            ### Frontend
            - Image: ${{ needs.build-and-push.outputs.frontend-image }}
            - Digest: ${{ needs.build-and-push.outputs.frontend-digest }}

            ### Deployment
            - Version: ${{ needs.build-and-push.outputs.version }}
            - Deployed at: ${{ github.event.head_commit.timestamp }}
            - Commit: ${{ github.sha }}
          draft: false
          prerelease: false

  # Notification
  notify:
    name: Notify Deployment Results
    runs-on: ubuntu-latest
    needs: [deploy-blue-green, post-deployment-tests]
    if: always()

    steps:
      - name: Notify Slack on success
        if: ${{ needs.deploy-blue-green.result == 'success' && needs.post-deployment-tests.result == 'success' }}
        uses: 8398a7/action-slack@v3
        with:
          status: success
          channel: "#deployments"
          text: "ðŸŽ‰ Production deployment successful!"
          fields: repo,message,commit,author,action,eventName,ref,workflow
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify Slack on failure
        if: ${{ needs.deploy-blue-green.result == 'failure' || needs.post-deployment-tests.result == 'failure' }}
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          channel: "#deployments"
          text: "ðŸš¨ Production deployment failed!"
          fields: repo,message,commit,author,action,eventName,ref,workflow
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Update deployment status
        uses: actions/github-script@v6
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'production',
              description: 'Production deployment',
              auto_merge: false
            });

            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: '${{ needs.deploy-blue-green.result == 'success' && needs.post-deployment-tests.result == 'success' ? 'success' : 'failure' }}',
              environment_url: '${{ secrets.PRODUCTION_FRONTEND_URL }}',
              description: 'Production deployment ${{ needs.deploy-blue-green.result == 'success' && needs.post-deployment-tests.result == 'success' ? 'successful' : 'failed' }}'
            });
